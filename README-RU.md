Каждому типу данных соответствует свой контрол - ДОМ-элемент.
- для ввода данных (инпут, селекте, датапикер и т.п.)
- для отображения данных (спан, див и т.п)

Разные типы данных могут быть представлены однотипным контролом:
- строка <input type=text>
- ЮРЛ <input type=text>

Каждый контрол ввода данных эмитит события:
- change - при финальном изменении
- keyup - во время ввода символов
- и др.

Хранилище может обновляться при любом нужном событии.

Изоморфное приложение позволяет только генерировать статическую разметку на серверной стороне. Любые события, объявленные в контроле будут проигнорированы.
Поэтому обработчики программно добавляются отдельно от статической разметки, используя всплытие и перехват.
Но в то же время в коде нужно хранить рядом - и обработчики и статическую разметку - для улучшения читабельности.

Документ (или корневой элемент) перехватывает все события изменения контролов ввода данных.

Если перечислять все типы инпутов, то нужно полностью перечислять весь ДОМ. Наверно лучше опираться только на свои типы.
Хотя наверно лучше следовать тому самому сопоставлению

Например контрол возраста должен сам определять ошибку, которая появляется при неправильном вводе.

Искать все контролы и привязывать ошибки, когда статическая разметка готова.
либо
Использовать перехват событий и определять ошибки на уровне корневого элемента.






Обычно кнопки добавляют/обновляют/удаляют данные
Инпуты позволяют не связывать кнопку (сабмит) с инпутом
Логика по выбору айдишника для новой записи
Если идшники туристов заняты, как пользователю выбрать?
Сделать тип: от 1 до 10 - исключая уже использованные.

Общую картинку довольно трудно воссоздать.
Типы данных определяются для конкретного проекта.
Также как и соответствующие контролы.

Любой проект содержит Item + ItemList
Любой тип данных - это и есть Item

Булевый тип (домен) состоит из двух записей в базе данных
id     name
true   SuperTrue
false  SuperFalse

NumberType
id  name
1   N1
2   N2
...
1234 N1234

Это всё типы данных, в большинстве случаев состоящие из одного ид

{
  name: String,
  age: Age,
  person: Person
}

В отличие от структур - простые типы однозначно определяются одним значением.
Простые типы - это по сути автогенерируемые таблицы. Например Номер - это таблица из 32степень записей (чисел)

https://types/number/1
https://types/person/123

// перечисляемого типа
Type 
Month = (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec); 
DayOfWeek = (Sun, Mon, Tue, Wen, Thu, Fri, Sat); 

// Интервальные типы

Year = 1900..2000; 
Letter = "A".."Z";

// Строковые типы

- набор симоволов - массив
Строка - это упакованный массив, компоненты которого имеют тип Char и тип индекса имеет нижнюю границу равную одному. К строкам применимы все 6 операций отношений, но строки при этом должны иметь равную длину.


Генерация разметки из вью-модели универсальна.
Все эти плюшки для вьюшки - 90% стили, 10% яваскрипт


ХТМЛ форма может служить как для обновления, так и добавления какой-либо записи: соответственно методы PUT, POST.
В случае обновления форма отображает поля конкретной существующей сущности. Пользователь может обновлять значения полей.
Идентификатор сущности не может быть обновлен. Но этот параметр по-прежнему нужно передавать на сервер.
Обычно ИД указан в адресной строке, например: `/product/1234`
Сама форма не содержит параметр ИД.
Форма отправляет PUT запрос на `/product/1234`
У страницы есть три режима:
- read /product/1234
- update /product/1234?update
- delete /product/1234?delete

Все остальные поля, кроме ИД и вычисляемых полей, могут обновляться.

Варианты дизайна для обновления
---

- отображаются читабельные поля, а по клику на спецкнопку переходят в режим редактирования (каждое поле по отдельности)
- редактирование поля завершается 
Для генерации страницы для чтения


Рендеринг проекта на серверной стороне.
---

- парсинг юрл-параметров
- построение модели на основе параметров
- вычисление калькулируемых свойств
- построение разметки на основе модели
- выдача разметки на клиент


Стилизация
---

Стиль - это представление. Каждая вью-модель имеет одно представление. Если одна вью-модель на страницу (наиболее предпочтительный вариант), то и будет одно представление.


### Оптимизация стилей

Представление имеет ту же иерархию, что и вью-модель. Иногда выгодно делать универсальный стиль для нескольких сущностей внутри модели. Например:
- однотипные сущности (компания покупателя и поставщика)
- массив сущностей (список продуктов)


### Однотипные сущности

Все свойства однотипных сущностей совпадают. Если не совпадают, то это разные типы: можно применить наследование для добавления специфичных свойств: Organization -> CustomerOrganization, SellerOrganization. Примеры:
- Organization: организация покупателя и поставщика
- ImageObject: логотип организации и аватар пользователя

CSS и различные препроцессоры позволяют хранить набор правил единым скопом, например:

```
:root {
  --image-object: {
    border: 1px solid yellow;
    background-color: red;
  };
}

.my-image {
  @apply --image-object;

  border-color: green;
}
```

Применение данной схемы позвояет описывать общие, частоупотребляемые правила для конкретного типа данных. Затем применять этот набор стилей в нужных местах и сразу после этого переопределять нужные параметры.

Данная схема позволяет избегать дублирования в самом коде, но при конвертации с помощью postcss в итоговом файле стили опять же будут дублироваться, что увеличит размер файла.

Новейшие версии браузеров http://caniuse.com/#feat=css-variables не требуют конвертации. Также процент потерь от использования данной схемы может быть незначительным.

### Массив

Сущности в списке чаще всего и выглядят одинаково. Обычно различия между элементами закладываются в саму модель, например в списке компаний указывать фирменный цвет каждой компании. На стороне представления обычно применяются разные стили только для наглядности, например:
- чередование цветов
- обособление первого или последнего элемента


Кейс: список продуктов (название, цена)

```
<div id="records" itemscope itemtype="http://schema.org/MusicAlbum">
  <span itemprop="name">King of Limbs</span>
  <span itemprop="byArtist">Radiohead</span>
  <div itemprop="track" itemscope itemtype="http://schema.org/ItemList">
    <span itemprop="numberOfItems" content=8 />
    <div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
      <span itemprop="position">1</span>
      <div id="records__1" itemprop="item" itemscope itemtype="http://schema.org/MusicRecording">
        <span itemprop="name">Bloom</span>
      </div>
    </div>
    <div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
      <span itemprop="position">2</span>
      <div id="records__2" itemprop="item" itemscope itemtype="http://schema.org/MusicRecording">
        <span itemprop="name">Morning Mr. Magpie</span>
      </div>
    </div>
    <div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
      <span itemprop="position">3</span>
      <div id="records__3" itemprop="item" itemscope itemtype="http://schema.org/MusicRecording">
        <span itemprop="name">Little by Little</span>
      </div>
    </div>
  </div>
</div>
```

Решение (свойства должны быть прямыми потомками соответствующей сущности):


Универсальный стиль для всех песен на странице:

- [itemtype="MusicRecording"] > [itemprop="name"]
- [itemtype="MusicRecording"] > [itemprop="description"]


Уникальный стиль для конкретной песни:

- #records__3 > [itemprop="name"] { color: green; }


Идентификаторы сущностей
---

Кейс: отображать список песен на сайте.

Решение:

обычно требуется отображать с привязкой к какой-либо корневой сущности, например:
- все песни конкретного исполнителя: Sting > songs
- все любимые песни пользователя: John > songs ? favorite
- топ-парад песен (привязка непосредственно к корню сайта): Site > songs ? top

То есть нет какой-либо конкретной страницы: /songs, отображающей песни без привязки к чему-либо. И вышеперечисленные варианты будут отображаться на страницах со следующими адресами:
- /Singer-Sting
- /User-John
- / (корень сайта)

Соответственно адреса страниц определяются схемой: Сущность-Идентификатор

Подобные составные идентификаторы можно использовать и в микроразметке данных, используя поле URL, как рекомендуемое поисковиками для идентификации сущности. Все сущности в БД имеют разные имена, поэтому пересечений не будет.
Поле URL - внутренний идентификатор в системе, а заодно и url-адрес на разрабатываемом сайте. Для внешних URL адресов используются другие свойства, например sameAs.

В названиях сущностей и идентификаторов желательно использовать только разрешённые символы для URL, например [A-Za-z0-9_-]. Это позволит избежать лишних работ по кодированию и декодированию данных для их использованию в веб-приложениях.

> Using the url property. Some web pages are about a specific item. For example, you may have a web page about a single person, which you could mark using the Person item type. Others have a collection of items. For example, your company website could have a page listing employees, with a link to a profile page for each person. For pages like this with a collection of items, you should mark each item separately (in this case a series of Persons) and add the url property to the link to the corresponding page for each item, like this:

```
<div itemscope itemtype="http://schema.org/Person"> <a href="alice.html" itemprop="url">Alice Jones</a> </div>
<div itemscope itemtype="http://schema.org/Person"> <a href="bob.html" itemprop="url">Bob Smith</a> </div>
```

